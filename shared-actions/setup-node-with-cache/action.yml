name: 'Setup Node with Enhanced Caching'
description: 'Setup Node.js with yarn caching and GitHub packages registry. Supports both setup-node and asdf-vm.'
inputs:
  node-version:
    description: 'Node.js version to use (ignored if use-asdf is true)'
    required: false
    default: '20'
  use-asdf:
    description: 'Use asdf-vm for version management (reads from .tool-versions)'
    required: false
    default: 'false'
  GH_TOKEN:
    description: 'GitHub token for private packages'
    required: true
  enable-yarn-cache:
    description: 'Enable yarn global cache (~/.cache/yarn)'
    required: false
    default: 'true'

runs:
  using: 'composite'
  steps:
    # Cache 1: asdf installations (Node.js and Yarn binaries)
    # This cache is separate because it only changes when .tool-versions is updated,
    # which happens infrequently (only when upgrading Node/Yarn versions).
    # By caching it separately, we avoid re-downloading binaries on every dependency change.
    - name: Cache asdf installations
      if: ${{ inputs.use-asdf == 'true' && !env.ACT }}
      uses: actions/cache@v4
      id: asdf-cache
      with:
        path: |
          ~/.asdf/installs
          ~/.asdf/plugins
        key: ${{ runner.os }}-${{ runner.arch }}-asdf-${{ hashFiles('**/.tool-versions') }}
        restore-keys: |
          ${{ runner.os }}-${{ runner.arch }}-asdf-
    
    - name: Set up Node.js with asdf
      if: ${{ inputs.use-asdf == 'true' }}
      uses: asdf-vm/actions/install@v3
    
    - name: Reshim asdf after cache restore
      if: ${{ inputs.use-asdf == 'true' && steps.asdf-cache.outputs.cache-hit == 'true' }}
      shell: bash
      run: |
        asdf reshim nodejs
        asdf reshim yarn
    
    - name: Set up Node.js with setup-node
      if: ${{ inputs.use-asdf != 'true' }}
      uses: actions/setup-node@v4
      with:
        node-version: ${{ inputs.node-version }}
    
    - name: Get yarn cache directory path
      id: yarn-cache-dir-path
      shell: bash
      run: echo "dir=$(yarn cache dir)" >> $GITHUB_OUTPUT
    
    - name: Set GitHub packages registry
      shell: bash
      run: |
        npm config set '//npm.pkg.github.com/:_authToken' ${{ inputs.GH_TOKEN }}
        npm config set @typeform:registry https://npm.pkg.github.com/
    
    # Cache 2: yarn dependencies (node_modules and yarn global cache)
    # This cache changes whenever package.json or yarn.lock is modified.
    # It's separate from the asdf cache so that dependency updates don't invalidate
    # the cached Node.js binaries, making builds more efficient.
    # Note: restore-keys allows partial matches, which can restore stale caches.
    # If you need to force a fresh install, manually delete old caches at:
    # https://github.com/Typeform/<repo>/actions/caches
    - name: Get yarn cache
      if: ${{ !env.ACT }}
      uses: actions/cache@v4
      id: yarn-cache
      with:
        path: |
          node_modules
          ~/.cache/yarn
        key: ${{ runner.os }}-${{ runner.arch }}-yarn-${{ hashFiles('**/yarn.lock', '**/package.json') }}
        restore-keys: |
          ${{ runner.os }}-${{ runner.arch }}-yarn-
    
    - name: Debug cache contents
      id: debug-cache
      if: ${{ !env.ACT && steps.yarn-cache.outputs.cache-hit == 'true' }}
      shell: bash
      run: |
        echo "=== üîç Cache Debug Info ==="
        echo "Cache key: ${{ runner.os }}-${{ runner.arch }}-yarn-${{ hashFiles('**/yarn.lock', '**/package.json') }}"
        echo ""
        
        echo "=== üì¶ Root node_modules Status ==="
        if [ -d "node_modules" ]; then
          MODULE_COUNT=$(ls -1 node_modules 2>/dev/null | wc -l | tr -d ' ')
          echo "‚úÖ node_modules exists"
          echo "üìä Package count: $MODULE_COUNT"
          echo "üîí Yarn integrity: $([ -f 'node_modules/.yarn-integrity' ] && echo '‚úÖ present' || echo '‚ùå missing')"
        else
          echo "‚ùå node_modules directory not found"
        fi
        echo ""
        
        echo "=== üè¢ Workspace Structure ==="
        WORKSPACE_PACKAGES=$(find packages/*/package.json apps/*/package.json -type f 2>/dev/null | wc -l | tr -d ' ')
        WORKSPACE_MODULES=$(find packages/*/node_modules apps/*/node_modules -maxdepth 0 -type d 2>/dev/null | wc -l | tr -d ' ')
        echo "üì¶ Workspace packages: $WORKSPACE_PACKAGES"
        echo "üîó Workspace node_modules: $WORKSPACE_MODULES"
        
        if [ "$WORKSPACE_PACKAGES" -gt 0 ]; then
          echo ""
          echo "Workspace packages found:"
          find packages/*/package.json apps/*/package.json -type f 2>/dev/null | sed 's|/package.json||' | sed 's|^|  - |'
        fi
        echo ""
    
    - name: Check if yarn install needed on cache hit
      id: check-install-needed
      if: ${{ !env.ACT }}
      shell: bash
      run: |
        # Determine if we need to run yarn install even when cache hits.
        #
        # Why this matters:
        # - Cache restores node_modules, but doesn't run postinstall hooks
        # - Monorepos need workspace linking even with cached node_modules
        # - Some projects have critical postinstall scripts (e.g., building native modules)
        # - Cached node_modules might be incomplete or corrupted
        #
        # We detect scenarios that require yarn install on cache hit:
        
        NEEDS_INSTALL=false
        CACHE_HIT="${{ steps.yarn-cache.outputs.cache-hit }}"
        
        # On cache hit, verify cache integrity before trusting it
        if [ "$CACHE_HIT" == "true" ]; then
          echo "=== üîç Verifying Cache Integrity ==="
          
          # Verification 1: Check if node_modules exists and has content
          if [ ! -d "node_modules" ]; then
            echo "‚ùå node_modules directory missing - forcing install"
            NEEDS_INSTALL=true
          else
            MODULE_COUNT=$(ls -1 node_modules 2>/dev/null | wc -l | tr -d ' ')
            if [ "$MODULE_COUNT" -lt 5 ]; then
              echo "‚ö†Ô∏è node_modules appears empty ($MODULE_COUNT packages) - forcing install"
              NEEDS_INSTALL=true
            fi
          fi
          
          # Verification 2: Check yarn integrity file
          if [ "$NEEDS_INSTALL" == "false" ] && [ ! -f "node_modules/.yarn-integrity" ]; then
            echo "‚ö†Ô∏è Missing .yarn-integrity file - cache may be incomplete, forcing install"
            NEEDS_INSTALL=true
          fi
          
          # Verification 3: For workspaces, verify workspace packages have node_modules
          if [ "$NEEDS_INSTALL" == "false" ]; then
            WORKSPACE_PACKAGES=$(find packages/*/package.json apps/*/package.json -type f 2>/dev/null | wc -l | tr -d ' ')
            if [ "$WORKSPACE_PACKAGES" -gt 0 ]; then
              WORKSPACE_MODULES=$(find packages/*/node_modules apps/*/node_modules -maxdepth 0 -type d 2>/dev/null | wc -l | tr -d ' ')
              if [ "$WORKSPACE_MODULES" -eq 0 ]; then
                echo "‚ö†Ô∏è Workspace packages exist but no workspace node_modules found - forcing install"
                NEEDS_INSTALL=true
              fi
            fi
          fi
          
          if [ "$NEEDS_INSTALL" == "false" ]; then
            echo "‚úÖ Cache integrity verified"
          fi
        fi
        
        # Only skip install for Turbo monorepos if cache is verified as complete
        if [ "$NEEDS_INSTALL" == "false" ]; then
          # 1. Yarn workspaces: Need symlink creation between workspace packages
          if grep -q '"workspaces"' package.json 2>/dev/null; then
            echo "üì¶ Detected Yarn workspaces"
            
            # Exception: Turbo monorepos don't need install on cache hit
            # Turbo caches include complete node_modules with correct structure
            if [ -f "turbo.json" ]; then
              echo "‚ö° Turbo monorepo detected - install NOT needed (cache verified complete)"
              NEEDS_INSTALL=false
            else
              echo "üîó Non-Turbo workspace - install needed for workspace linking"
              NEEDS_INSTALL=true
            fi
          fi
          
          # 2. Lerna monorepo: Need lerna bootstrap (usually in postinstall hook)
          if [ -f "lerna.json" ]; then
            echo "üì¶ Detected Lerna monorepo - install needed for lerna bootstrap"
            NEEDS_INSTALL=true
          fi
          
          # 3. Postinstall hook: Any project with postinstall needs it executed
          #    Examples: building native modules, generating files, running setup scripts
          if grep -q '"postinstall"' package.json 2>/dev/null; then
            echo "üîß Detected postinstall hook - install needed to execute it"
            NEEDS_INSTALL=true
          fi
        fi
        
        echo "needs-install=$NEEDS_INSTALL" >> $GITHUB_OUTPUT
    
    - name: Log cache status and decision
      if: ${{ !env.ACT }}
      shell: bash
      run: |
        echo "=== üìä Cache Status Summary ==="
        if [ "${{ steps.yarn-cache.outputs.cache-hit }}" == "true" ]; then
          echo "‚úÖ Cache HIT - Dependencies restored from cache"
          echo "üì¶ Cache key: ${{ runner.os }}-${{ runner.arch }}-yarn-${{ hashFiles('**/yarn.lock', '**/package.json') }}"
          echo ""
          if [ "${{ steps.check-install-needed.outputs.needs-install }}" == "true" ]; then
            echo "üîÑ Decision: WILL run yarn install"
            echo "Reasons: Cache verification failed, workspace linking needed, or postinstall hooks detected"
          else
            echo "‚ö° Decision: SKIP yarn install"
            echo "Reason: Turbo monorepo with verified complete cache"
          fi
        else
          echo "‚ùå Cache MISS - Fresh installation required"
          echo "üîç Looking for key: ${{ runner.os }}-${{ runner.arch }}-yarn-${{ hashFiles('**/yarn.lock', '**/package.json') }}"
          echo ""
          echo "üîÑ Decision: WILL run yarn install"
        fi
        echo ""
    
    - name: Install Node.js dependencies
      if: ${{ !env.ACT && (steps.yarn-cache.outputs.cache-hit != 'true' || steps.check-install-needed.outputs.needs-install == 'true') }}
      shell: bash
      run: yarn install --frozen-lockfile
      env:
        NODE_AUTH_TOKEN: ${{ inputs.GH_TOKEN }}